#Script to map NGS data to a fasta file or a CSV of oligos ordered.
#CSV has the following columns: pool_id,pool_primer_set,aa_seq,full_oligo_seq,oligo_length,BsaI_count
#Usually generated by AM
import argparse
import numpy as np
import pandas as pd
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from Bio import SeqIO
from Bio.SeqIO import FastaIO
from Bio import pairwise2
from collections import OrderedDict
import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt

def read_fasta(fasta_file):
	the_fastas = SeqIO.parse(fasta_file,'fasta')
	return the_fastas

def read_oligos(csv_file,key,start,end,wt,exact):
	in_df = pd.read_csv(csv_file,header=0)
	if exact == False:
		in_df = in_df[in_df['pool_id'].str.contains(
						str(key),regex=False)]
	else:
		in_df = in_df[in_df['pool_id']==key]
	out_list = []
	for x in range(0,in_df.shape[0]):
		temp=SeqRecord(Seq(in_df.iat[x,2]),id=None,
			name="{0}_{1}".format(in_df.iat[x,0],x),
			description='')
		out_list.append(temp)
	if wt is not None:
		out_list.append(SeqRecord(Seq(wt),id=None,name="wildtype",
			description=''))
	else:
		pass
	if start is not None:
		out_list.append(SeqRecord(Seq(start),id=None,name="full_start",
			description=''))
	else:
		out_list.append(SeqRecord('',id=None,name="full_start",
			description=''))
	if end is not None:
		out_list.append(SeqRecord(Seq(end),id=None,name='full_end',description=''))
	else:
		out_list.append(SeqRecord('',id=None,name='full_end',description=''))
	return out_list

def read_dna(csv_file,start,end,wt):
	in_df = pd.read_csv(csv_file,header=0)
	out_list = []
	for x in range(0,in_df.shape[0]):
		temp=SeqRecord(Seq(in_df.iat[x,1]),id=None,name="Seq{0}".format(x),
			description='')
		out_list.append(temp)
	if wt is not None:
		out_list.append(SeqRecord(Seq(wt),id=None,name="wildtype",
			description=''))
	else:
		pass
	if start is not None:
		out_list.append(SeqRecord(Seq(start),id=None,name="full_start",
			description=''))
	else:
		out_list.append(SeqRecord('',id=None,name="full_start",
			description=''))
	if end is not None:
		out_list.append(SeqRecord(Seq(end),id=None,name='full_end',description=''))
	else:
		out_list.append(SeqRecord('',id=None,name='full_end',description=''))
	return out_list

def read_counts(count_file):
	out_df = pd.read_csv(count_file,header=None)
	out_df.columns=['translation','none','count']
	print out_df.dtypes
	return out_df

def read_dna_counts(count_file):
	out_df = pd.read_csv(count_file,header=0)
	return out_df

def read_raw_reads(count_file):
	out_df = pd.read_csv(count_file,header=None)
	out_df.columns = ['sequence']
	return out_df

def match_fastas(count_df,the_fastas):
#	print count_df['translation']
	out_dict=OrderedDict()
	fasta_list = []
	og_count_df = count_df.copy()
#This for loop cycles through the fasta list and searches for the sequence of the fasta in the count_df dataframe. It also sorts the values of the df based on count and appends them to out_dict
	for rec in the_fastas:
		fasta_list.append(rec)
		if rec.name != 'full_start' and rec.name != 'full_end':
			out_df=pd.DataFrame(
				count_df[count_df['translation'].str.contains(
					str(rec.seq),regex=False)].copy())
			count_df = pd.DataFrame(
				count_df[~count_df['translation'].str.contains(
					str(rec.seq),regex=False)].copy())
			out_df.sort_values(['count'],inplace=True)
			out_dict[rec.name]=out_df
		elif rec.name == 'full_start':
			full_start = rec
		elif rec.name == 'full_end':
			full_end = rec
		else:
			pass
	full_out_dict = OrderedDict()
	final_out_dict = OrderedDict()
#This for loop cycles through out dict, matches them to fasta_list, and then searches for the full 5'_leader+target_sequence+3'_ender
	for k in out_dict:
		for fas in fasta_list:
			if k==fas.name:
#				print k
				full_seq = full_start.seq+fas.seq+full_end.seq
				fout_df = pd.DataFrame(
					out_dict[k][out_dict[k]['translation'].str.contains(
						str(full_seq),regex=False)].copy())
				fout_df.sort_values(['count'],inplace=True)
				full_out_dict[k]=fout_df
				final_out_dict[k]=[full_seq,np.sum(fout_df['count'])]
			else:
				pass
	total_len = len(full_start.seq+fasta_list[0].seq+full_end.seq)
	short_reads = og_count_df[og_count_df['translation'].str.len()<total_len].copy().shape[0]
	total_right_len = og_count_df[og_count_df['translation'].str.len()==total_len].copy().shape[0]
	total_reads = np.sum(og_count_df['count'])
	total_muts = np.sum([final_out_dict[k][1] for k in final_out_dict.keys()])
	final_out_dict['total_oligos'] = [None,total_muts]
	final_out_dict['Short_reads']=[None,short_reads]
	final_out_dict['Unmatched']=[None,total_reads-total_muts-short_reads]

	return out_dict,full_out_dict,final_out_dict,count_df


def dna_match_fastas(count_df,the_fastas):
	out_dict=OrderedDict()
	fasta_list = []
	og_count_df = count_df.copy()
	count_df = count_df.dropna(how='any',axis=0)
#This for loop cycles through the fasta list and searches for the sequence of the fasta in the count_df dataframe. It also sorts the values of the df based on count and appends them to out_dict
	for rec in the_fastas:
		fasta_list.append(rec)
		if rec.name != 'full_start' and rec.name != 'full_end':
			out_df=pd.DataFrame(
				count_df[count_df.iloc[:,1].str.contains(
					str(rec.seq),regex=False)].copy())
			count_df = pd.DataFrame(
				count_df[~count_df.iloc[:,1].str.contains(
					str(rec.seq),regex=False)].copy())
			out_df.sort_values(['count'],inplace=True)
			out_dict[rec.name]=out_df
		elif rec.name == 'full_start':
			full_start = rec
		elif rec.name == 'full_end':
			full_end = rec
		else:
			pass
	full_out_dict = OrderedDict()
	final_out_dict = OrderedDict()
#This for loop cycles through out dict, matches them to fasta_list, and then searches for the full 5'_leader+target_sequence+3'_ender
	for k in out_dict:
		for fas in fasta_list:
			if k==fas.name:
#				print k
				full_seq = full_start.seq+fas.seq+full_end.seq
				fout_df = pd.DataFrame(
					out_dict[k][out_dict[k].iloc[:,1].str.contains(
						str(full_seq),regex=False)].copy())
				fout_df.sort_values(['count'],inplace=True)
				full_out_dict[k]=fout_df
				final_out_dict[k]=[full_seq,np.sum(fout_df['count'])]
			else:
				pass
	total_len = len(full_start.seq+fasta_list[0].seq+full_end.seq)
	short_reads = og_count_df[og_count_df.iloc[:,1].str.len()<total_len].copy().shape[0]
	total_right_len = og_count_df[og_count_df.iloc[:,1].str.len()==total_len].copy().shape[0]
	total_reads = np.sum(og_count_df['count'])
	total_muts = np.sum([final_out_dict[k][1] for k in final_out_dict.keys()])
	final_out_dict['total_oligos'] = [None,total_muts]
	final_out_dict['Short_reads']=[None,short_reads]
	final_out_dict['Unmatched']=[None,total_reads-total_muts-short_reads]
	return out_dict,full_out_dict,final_out_dict,count_df
	
def align_match(count_df,the_fastas):
	fasta_list = []
	final_out_dict = OrderedDict()
	read_out_dict = OrderedDict()
	for rec in the_fastas:
		if rec.name != 'full_start' and rec.name != 'full_end':
			fasta_list.append(rec)
		elif rec.name == 'full_start':
			full_start = rec
		elif rec.name == 'full_end':
			full_end = rec
		else:
			pass
	for fas in fasta_list:
		found = 0
		for x in range(0,count_df.shape[0]):
			full_seq = full_start.seq+fas.seq+full_end.seq
#			print count_df.iat[x,0]
			scores = pairwise2.align.localms(count_df.iat[x,0], full_seq, 1,0,0,0, score_only=True)
			try:
				len(scores)
				best_scoring=max(scores)
			except TypeError:
				best_scoring=scores
			if scores>=len(full_seq)-1:
				found +=1
				read_out_dict[x]=[fas.name,fas.seq,count_df.iat[x,0]]
			else:
				pass
		final_out_dict[fas.name]=[fas.seq,found]
	return final_out_dict,read_out_dict


#Under Development
def scoring_aligns(seq,fas):
	scores = pairwise2.align.localms(count_df.iat[x,0], full_seq, 1,0,0,0, score_only=True)
	try:
		len(scores)
		best_scoring=max(scores)
	except TypeError:
		best_scoring=scores
	if scores>=len(full_seq)-1:
		return 1
	else:
		return 0

#Under Development
def align_match2(count_df,the_fastas):
	fasta_list = []
	final_out_dict = OrderedDict()
	read_out_dict = OrderedDict()
	for rec in the_fastas:
		if rec.name != 'full_start' and rec.name != 'full_end':
			fasta_list.append(rec)
		elif rec.name == 'full_start':
			full_start = rec
		elif rec.name == 'full_end':
			full_end = rec
		else:
			pass
	for fas in fasta_list:
		full_seq = full_start.seq+fas.seq+full_end.seq
		count_df[fas] = count_df.apply(lambda x: align_match(x['sequence'],fas))
	for col in count_df.columns.values[1:]:
		final_out_dict[col]=np.sum(count_df[col])
	return final_out_dict

				
				
			

def plot_hist(in_df,name):
	fig,ax = plt.subplots(1,1)
	ax.hist(in_df.iloc[:-3,1])
	ax.spines['right'].set_visible(False)
	ax.spines['top'].set_visible(False)
	ax.set_ylabel('Abundance')
	ax.set_xlabel('Sequence_count')
	if name is not None:
		plt.savefig('{0}_curated_counts_hist.pdf'.format(name))
	else:
		plt.savefig('curated_counts_hist.pdf')
	plt.close()
	
if __name__ == '__main__':
	parser = argparse.ArgumentParser(description='script to analyze 7b mutant Miseq data')
	required=parser.add_argument_group('Required')
	required.add_argument('--input','-i',required=True,
		help='Input MiSeq read counts analysis')
	required.add_argument('--fastas','-f',required=True,
		help='Fasta of fragments of desired variants')
	parser.add_argument('--five','-5',required=False,default=None,
		help='Five prime constant sequence if not already included in fasta ')
	parser.add_argument('--three','-3',required=False,default=None,
		help='Three prime constant sequence if not already included in fasta')
	parser.add_argument('--write_all','-w',required=False,default=False,
		action='store_true',help='Write all matching sequences to query')
	parser.add_argument('--key','-k',required=False,default=None,
		help='Key in the CSV file of oligo sequences to match to.')
	parser.add_argument('-wt',required=False,default=None,
		help='Wildtype amino acid sequence')
	parser.add_argument('--exact','-e',required=False,default=False,action='store_true',
		help='Call this flag to force exact match to the key')
	parser.add_argument('--output','-o',required=False,default=None,
		help='Specify output filename')
	parser.add_argument('-dna', required=False,default=False,action='store_true',
		help='Call this flag if matching DNA instead of amino acids')
	parser.add_argument('--align','-a',required=False,default=False,action='store_true',
		help='Call this flag to do alignments instead of string matches')
	parser.add_argument('--to_csv','-c',required=False,default=False,action='store_true',
		help='Call this flag to write csv instead of to stdout')
	
	
	parsed = parser.parse_args()
	if parsed.input.endswith('.fasta'):
		the_fastas = read_fasta(parsed.fastas)
	else:
		if parsed.dna==False:
			the_fastas = read_oligos(parsed.fastas,parsed.key,
				parsed.five,parsed.three,parsed.wt,parsed.exact)
			count_df = read_counts(parsed.input)
		else:
			the_fastas = read_dna(parsed.fastas,parsed.five,parsed.three,parsed.wt)
			if parsed.align == False:
				count_df = read_dna_counts(parsed.input)
			else:
				count_df = read_raw_reads(parsed.input)
	if parsed.dna == True:
		if parsed.align == True:
			full_out_dict,read_out_dict = align_match(count_df,the_fastas)
			full_out_df = pd.DataFrame.from_dict(full_out_dict,orient='index')
			read_out_df = pd.DataFrame.from_dict(read_out_dict,orient='index')
			if parsed.to_csv == True:
				if parsed.output is not None:
					full_out_df.to_csv('{0}_aligned_counts.csv'.format(parsed.output))
					read_out_df.to_csv('{0}_aligned_matches.csv'.format(parsed.output))
				else:
					full_out_df.to_csv('aligned_counts.csv')
					read_out_df.to_csv('aligned_matches.csv')
			else:
				full_out_df.to_csv()
		else:
			out_dict,full_out_dict,final_out_dict,mod_count_df = dna_match_fastas(
			count_df,the_fastas)
			if parsed.write_all == True:
				for k in full_out_dict:
					full_out_dict[k].to_csv('{0}_full_out.csv'.format(k))
			else:
				pass
			final_out_df = pd.DataFrame.from_dict(final_out_dict,orient='index')
			final_out_df.columns=['sequence','count']
			if parsed.to_csv == True:
				if parsed.output is not None:
					mod_count_df.to_csv(
						'{0}_nonmatched_sequences.csv'.format(parsed.output))
					final_out_df.to_csv('{0}_curated_counts.csv'.format(parsed.output))
				else:
					mod_count_df.to_csv('nonmatched_sequences.csv')
					final_out_df.to_csv('curated_counts.csv')
			else:
				final_out_df.to_csv()
	else:
		out_dict,full_out_dict,final_out_dict,mod_count_df = match_fastas(
			count_df,the_fastas)
		if parsed.write_all == True:
			for k in full_out_dict:
				full_out_dict[k].to_csv('{0}_full_out.csv'.format(k))
		else:
			pass
		final_out_df = pd.DataFrame.from_dict(final_out_dict,orient='index')
		final_out_df.columns=['sequence','count']
		print final_out_df
		if parsed.to_csv == True:
			if parsed.output is not None:
				mod_count_df.to_csv('{0}_nonmatched_sequences.csv'.format(parsed.output))
				final_out_df.to_csv('{0}_curated_counts.csv'.format(parsed.output))
			else:
				mod_count_df.to_csv('nonmatched_sequences.csv')
				final_out_df.to_csv('curated_counts.csv')
		else:
			final_out_df.to_csv()
	plot_hist(final_out_df,parsed.output)
